package main

import (
  "context"
  "fmt"
  "net/http"
  "math"
  "math/rand"
  "time"

  shippingservice "shipping/gen"        // generated by protoc-gen-go
  "shipping/gen/genconnect" // generated by protoc-gen-connect-go

  "connectrpc.com/connect"
  "connectrpc.com/validate"
)

type Quote struct {
	Dollars uint32
	Cents   uint32
}

// String representation of the Quote.
func (q Quote) String() string {
	return fmt.Sprintf("$%d.%d", q.Dollars, q.Cents)
}

// CreateQuoteFromCount takes a number of items and returns a Price struct.
func CreateQuoteFromCount(count int) Quote {
	return CreateQuoteFromFloat(8.99)
}

// CreateQuoteFromFloat takes a price represented as a float and creates a Price struct.
func CreateQuoteFromFloat(value float64) Quote {
	units, fraction := math.Modf(value)
	return Quote{
		uint32(units),
		uint32(math.Trunc(fraction * 100)),
	}
}

var seeded bool = false

// CreateTrackingId generates a tracking ID.
func CreateTrackingId(salt string) string {
	if !seeded {
		rand.Seed(time.Now().UnixNano())
		seeded = true
	}

	return fmt.Sprintf("%c%c-%d%s-%d%s",
		getRandomLetterCode(),
		getRandomLetterCode(),
		len(salt),
		getRandomNumber(3),
		len(salt)/2,
		getRandomNumber(7),
	)
}

// getRandomLetterCode generates a code point value for a capital letter.
func getRandomLetterCode() uint32 {
	return 65 + uint32(rand.Intn(25))
}

// getRandomNumber generates a string representation of a number with the requested number of digits.
func getRandomNumber(digits int) string {
	str := ""
	for i := 0; i < digits; i++ {
		str = fmt.Sprintf("%s%d", str, rand.Intn(10))
	}

	return str
}


type ShippingServer struct{}

func (s *ShippingServer) GetQuote(
  _ context.Context,
  req *shippingservice.GetQuoteRequest,
) (*shippingservice.GetQuoteResponse, error) {
	quote := CreateQuoteFromCount(0)
	fmt.Println("got here")

	// 2. Generate a response.
	return &shippingservice.GetQuoteResponse{
		CostUsd: &shippingservice.Money{
			CurrencyCode: "USD",
			Units:        int64(quote.Dollars),
			Nanos:        int32(quote.Cents * 10000000)},
	}, nil
}

func (s *ShippingServer) ShipOrder(
	_ context.Context,
	req *shippingservice.ShipOrderRequest) (*shippingservice.ShipOrderResponse, error) {
	baseAddress := fmt.Sprintf("%s, %s, %s", req.Address.StreetAddress, req.Address.City, req.Address.State)
	id := CreateTrackingId(baseAddress)

	// 2. Generate a response.
	return &shippingservice.ShipOrderResponse{
		TrackingId: id,
	}, nil
}

func main() {
  shipper := &ShippingServer{}
  mux := http.NewServeMux()
  path, handler := genconnect.NewShippingServiceHandler(
    shipper,
    // Validation via Protovalidate is almost always recommended
    connect.WithInterceptors(validate.NewInterceptor()),
  )
  mux.Handle(path, handler)
  p := new(http.Protocols)
  p.SetHTTP1(true)
  // Use h2c so we can serve HTTP/2 without TLS.
  p.SetUnencryptedHTTP2(true)
  s := http.Server{
    Addr:      "localhost:8080",
    Handler:   mux,
    Protocols: p,
  }
  s.ListenAndServe()
}

